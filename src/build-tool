#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Unified Build Tool
# Copyright (C) 2021-2022 by Thomas Dreibholz
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact: dreibh@iem.uni-due.de

import glob
import os
import pprint
import re
import sys
import time


# ###########################################################################
# #### Constants                                                         ####
# ###########################################################################

TarballFormats = [ 'xz', 'bz2', 'gz' ]

Systems = [
   # Prefix       System Name         Configuration File
   [ 'cmake',    'CMake',             'cmake_lists_name'      ],
   [ 'autoconf', 'AutoConf/AutoMake', 'autoconf_config_name'  ],
   [ 'other',    'Version File',      'other_file_name'       ],
   [ 'rpm',      'RPM Spec',          'rpm_spec_name'         ],
   [ 'debian',   'Debian Changelog',  'debian_changelog_name' ],
   [ 'port',     'Port Makefile',     'port_makefile_name'    ]
]



# ###########################################################################
# #### Helper Functions                                                  ####
# ###########################################################################


# ###### Print section header ###############################################
def printSection(title):
   now = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime())
   sys.stdout.write('\n\x1b[34m' + (now + ' ====== ' + title + ' ').ljust(78, '=') + '\x1b[0m\n')



# ###########################################################################
# #### Packaging                                                         ####
# ###########################################################################


# ###### Read packaging configuration from packaging.conf ###################
def readPackagingConfiguration():

   # ====== Initialise ======================================================
   packageInfo = {}
   packageInfo['packaging_maintainer']  = None
   packageInfo['packaging_make_dist']   = None
   packageInfo['packaging_config_name'] = 'packaging.conf'

   # ====== Obtain package configuration ====================================
   re_package_maintainer = re.compile(r'^(MAINTAINER=\")(.*)(\".*$)')
   re_package_makedist   = re.compile(r'^(MAKE_DIST=\")(.*)(\".*$)')
   try:
      packagingConfFile = open(packageInfo['packaging_config_name'], 'r', encoding='utf-8')
      packagingConfFileContents = packagingConfFile.readlines()
      for line in packagingConfFileContents:
         match = re_package_maintainer.match(line)
         if match != None:
            packageInfo['packaging_maintainer'] = match.group(2)
         else:
            match = re_package_makedist.match(line)
            if match != None:
               packageInfo['packaging_make_dist'] = match.group(2)
      packagingConfFile.close()
   except Exception as e:
      sys.stderr.write('ERROR: Unable to read ' + packageInfo['packaging_config_name'] + ': ' + str(e) + '\n')
      sys.exit(1)

   if packageInfo['packaging_maintainer'] == None:
      sys.stderr.write('ERROR: Unable to find MAINTAINER in ' + packageInfo['packaging_config_name'] + ': ' + str(e) + '\n')
      sys.exit(1)
   elif packageInfo['packaging_make_dist'] == None:
      sys.stderr.write('ERROR: Unable to find MAKE_DIST in ' + packageInfo['packaging_config_name'] + ': ' + str(e) + '\n')
      sys.exit(1)

   return packageInfo


# ###### Read CMake packaging information ###################################
def readCMakePackagingInformation():

   # ====== Initialise ======================================================
   packageInfo = {}

   # ====== Obtain package configuration ====================================
   cmakeListsFile = 'CMakeLists.txt'
   if os.path.isfile(cmakeListsFile):
      re_cmake_project   = re.compile(r'[ \t]*PROJECT[ \t]*\(([a-zA-Z0-9-+]+)')
      re_cmakefile_major = re.compile(r'^[Ss][Ee][Tt]\(BUILD_MAJOR[ \t]*"(\d+)"[ \t]*\)')
      re_cmakefile_minor = re.compile(r'^[Ss][Ee][Tt]\(BUILD_MINOR[ \t]*"(\d+)"[ \t]*\)')
      re_cmakefile_patch = re.compile(r'^[Ss][Ee][Tt]\(BUILD_PATCH[ \t]*"(\d+)(~[a-zA-Z0-9\.+]+|)"[ \t]*\)')

      packageInfo['cmake_lists_name'] = cmakeListsFile
      try:
         cmakeFile = open(packageInfo['cmake_lists_name'], 'r', encoding='utf-8')
         cmakeFileContents = cmakeFile.readlines()
         for line in cmakeFileContents:
            match = re_cmakefile_major.match(line)
            if match != None:
               packageInfo['cmake_version_major'] = int(match.group(1))
            else:
               match = re_cmakefile_minor.match(line)
               if match != None:
                  packageInfo['cmake_version_minor'] = int(match.group(1))
               else:
                  match = re_cmakefile_patch.match(line)
                  if match != None:
                     packageInfo['cmake_version_patch'] = int(match.group(1))
                     packageInfo['cmake_version_extra'] = match.group(2)
                  else:
                     match = re_cmake_project.match(line)
                     if match != None:
                        packageInfo['cmake_package'] = match.group(1)
         cmakeFile.close()

         if (packageInfo['cmake_version_major'] != None) and \
            (packageInfo['cmake_version_minor'] != None) and \
            (packageInfo['cmake_version_patch'] != None) and \
            (packageInfo['cmake_version_extra'] != None):
            packageInfo['cmake_version_string'] = str(packageInfo['cmake_version_major']) + '.' + \
                                 str(packageInfo['cmake_version_minor']) + '.' + \
                                 str(packageInfo['cmake_version_patch']) + packageInfo['cmake_version_extra']

      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + packageInfo['cmake_lists_name'] + ': ' + str(e) + '\n')
         sys.exit(1)

      # ====== Check whether information is complete ========================
      if ( ( not 'cmake_package' in packageInfo) or
           ( not 'cmake_version_string' in packageInfo ) ):
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + packageInfo['cmake_lists_name'] + '!\n')
         sys.exit(1)

   return packageInfo


# ###### Read AutoConf packaging information ################################
def readAutoConfPackagingInformation():

   # ====== Initialise ======================================================
   packageInfo = {}

   # ====== Obtain package configuration ====================================
   for autoconfConfigName in [ 'configure.ac', 'configure.in' ]:
      if os.path.isfile(autoconfConfigName):
         break
   if os.path.isfile(autoconfConfigName):
      re_autoconffile_version = re.compile(r'^AC_INIT\([ \t]*\[(.*)\][ \t]*,[ \t]*\[(\d).(\d).(\d+)([~+][a-zA-Z0-9\.+]+|)\][ \t]*,[ \t]*\[(.*)\][ \t]*\)')

      packageInfo['autoconf_config_name'] = autoconfConfigName
      try:
         autoconfFile = open(packageInfo['autoconf_config_name'], 'r', encoding='utf-8')
         autoconfFileContents = autoconfFile.readlines()
         for line in autoconfFileContents:
            match = re_autoconffile_version.match(line)
            if match != None:
               packageInfo['autoconf_package']       = match.group(1)
               packageInfo['autoconf_version_major'] = int(match.group(2))
               packageInfo['autoconf_version_minor'] = int(match.group(3))
               packageInfo['autoconf_version_patch'] = int(match.group(4))
               packageInfo['autoconf_version_extra'] = match.group(5)
               packageInfo['autoconf_version_string'] = \
                  str(packageInfo['autoconf_version_major']) + '.' + \
                  str(packageInfo['autoconf_version_minor']) + '.' + \
                  str(packageInfo['autoconf_version_patch']) + packageInfo['autoconf_version_extra']
               break
         autoconfFile.close()

      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + packageInfo['autoconf_config_name'] + ': ' + str(e) + '\n')
         sys.exit(1)

      # ====== Check whether information is complete ========================
      if ( ( not 'autoconf_package' in packageInfo) or
           ( not 'autoconf_version_string' in packageInfo ) ):
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + packageInfo['autoconf_config_name'] + '!\n')
         sys.exit(1)

   return packageInfo


# ###### Read Debian packaging information ##################################
def readDebianPackagingInformation():

   # ====== Initialise ======================================================
   packageInfo = {}

   # ====== Process changelog file ==========================================
   debianChangelogName = 'debian/changelog'
   debianControlName   = 'debian/control'
   if os.path.isfile(debianChangelogName):
      re_debian_version = re.compile(r'^([a-zA-Z0-9-+]+)[ \t]*\((\d+:|)(\d+)\.(\d+)\.(\d+)(.*|)-(\d|\d[a-zA-Z-+~]+\d|)\)[ \t]*([a-zA-Z-+]+)[ \t]*;')
      re_debian_itp1    = re.compile(r'^ * .*ITP.*Closes: #([0-9]+).*$')
      re_debian_itp2    = re.compile(r'^ * .*Closes: #([0-9]+).*ITP.*$')

      packageInfo['debian_changelog_name']    = debianChangelogName
      packageInfo['debian_control_name']      = debianControlName
      packageInfo['debian_package_name']      = None
      packageInfo['debian_version_string']    = None
      packageInfo['debian_standards_version'] = None
      packageInfo['debian_codename']          = None
      packageInfo['debian_itp']               = None
      packageInfo['debian_status']            = None

      try:
         debianChangeLogFile = open(debianChangelogName, 'r', encoding='utf-8')
         debianChangeLogFileContents = debianChangeLogFile.readlines()
         n = 0
         for line in debianChangeLogFileContents:
            n = n + 1
            if n == 1:
               match = re_debian_version.match(line)
               if match != None:
                  packageInfo['debian_package_name']      = match.group(1)
                  packageInfo['debian_version_prefix']    = match.group(2)
                  packageInfo['debian_version_major']     = int(match.group(3))
                  packageInfo['debian_version_minor']     = int(match.group(4))
                  packageInfo['debian_version_patch']     = int(match.group(5))
                  packageInfo['debian_version_extra']     = match.group(6)
                  packageInfo['debian_version_packaging'] = match.group(7)
                  packageInfo['debian_codename']          = match.group(8)
                  packageInfo['debian_version_string']    = \
                     str(packageInfo['debian_version_major']) + '.' + \
                     str(packageInfo['debian_version_minor']) + '.' + \
                     str(packageInfo['debian_version_patch']) + packageInfo['debian_version_extra']
            elif n > 1:
               match = re_debian_itp1.match(line)
               if match == None:
                  match = re_debian_itp2.match(line)
               if match != None:
                  # print('ITP: ' + line)
                  packageInfo['debian_itp'] = int(match.group(1))
                  break
         debianChangeLogFile.close()

      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + debianChangelogName + ': ' + str(e) + '\n')
         sys.exit(1)

      if packageInfo['debian_package_name'] == None:
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + debianChangelogName + '!\n')
         sys.exit(1)

      # ====== Check whether information is complete ========================
      if not 'debian_package_name' in packageInfo:
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + debianChangelogName + '!\n')
         sys.exit(1)

      # ====== Process control file =========================================
      re_debian_standards_version = re.compile(r'^Standards-Version:[ \t]*([0-9\.]*)[ \t]*$')
      try:
         debianControlFile = open(debianControlName, 'r', encoding='utf-8')
         debianControlFileContents = debianControlFile.readlines()
         for line in debianControlFileContents:
            match = re_debian_standards_version.match(line)
            if match != None:
               packageInfo['debian_standards_version'] = match.group(1)
         debianControlFile.close()
      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + debianControlName + ': ' + str(e) + '\n')
         sys.exit(1)

   return packageInfo


# ###### Read RPM packaging information #####################################
def readRPMPackagingInformation():

   # ====== Initialise ======================================================
   packageInfo = {}

   # ====== Obtain package configuration ====================================
   rpm_spec_names = glob.glob('rpm/*.spec')
   if len(rpm_spec_names) > 0:
      packageInfo['rpm_spec_name'] = rpm_spec_names[0]

      re_rpm_name    = re.compile(r'^(Name:[ \t]*)(\S+)')
      re_rpm_version = re.compile(r'^(Version:[ \t]*)(\d+)\.(\d+)\.(\d+)(.*|)')
      re_rpm_release = re.compile(r'^(Release:[ \t]*)(\d+)')
      try:
         rpmSpecFile = open(packageInfo['rpm_spec_name'], 'r', encoding='utf-8')
         rpmSpecFileContents = rpmSpecFile.readlines()
         packageInfo['rpm_version_packaging'] = None
         for line in rpmSpecFileContents:
            match = re_rpm_version.match(line)
            if match != None:
               packageInfo['rpm_version_major']  = int(match.group(2))
               packageInfo['rpm_version_minor']  = int(match.group(3))
               packageInfo['rpm_version_patch']  = int(match.group(4))
               packageInfo['rpm_version_extra']  = match.group(5)
               packageInfo['rpm_version_string'] = \
                  str(packageInfo['rpm_version_major']) + '.' + \
                  str(packageInfo['rpm_version_minor']) + '.' + \
                  str(packageInfo['rpm_version_patch']) + packageInfo['rpm_version_extra']
            else:
               match = re_rpm_release.match(line)
               if match != None:
                  packageInfo['rpm_version_packaging'] = int(match.group(2))
               else:
                  match = re_rpm_name.match(line)
                  if match != None:
                     packageInfo['rpm_package_name'] = match.group(2)
         rpmSpecFile.close()

      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + packageInfo['rpm_spec_name'] + ': ' + str(e) + '\n')
         sys.exit(1)

      # ====== Check whether information is complete ========================
      if ( (not 'rpm_package_name' in packageInfo) or
           (not 'rpm_version_packaging' in packageInfo) ):
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + packageInfo['rpm_spec_name'] + '!\n')
         sys.exit(1)

   return packageInfo


# ###### Read FreeBSD ports packaging information ###########################
def readFreeBSDPackagingInformation():

   # ====== Initialise ======================================================
   packageInfo = {}
   port_makefile_names = glob.glob('freebsd/*/Makefile')

   # ====== Obtain package configuration ====================================
   if len(port_makefile_names) > 0:
      packageInfo['port_makefile_name'] = port_makefile_names[0]
      re_freebsd_version = re.compile(r'^(PORTVERSION=[ \t]*)(\d+)\.(\d+)\.(\d+)(.*|)')
      try:
         freeBSDMakefileFile = open(packageInfo['port_makefile_name'], 'r', encoding='utf-8')
         freeBSDMakefileFileContents = freeBSDMakefileFile.readlines()
         for line in freeBSDMakefileFileContents:
            match = re_freebsd_version.match(line)
            if match != None:
               packageInfo['port_version_major']  = int(match.group(2))
               packageInfo['port_version_minor']  = int(match.group(3))
               packageInfo['port_version_patch']  = int(match.group(4))
               packageInfo['port_version_extra']  = match.group(5)
               packageInfo['port_version_string'] = \
                  str(packageInfo['port_version_major']) + '.' + \
                  str(packageInfo['port_version_minor']) + '.' + \
                  str(packageInfo['port_version_patch']) + packageInfo['port_version_extra']
         freeBSDMakefileFile.close()

      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + packageInfo['port_makefile_name'] + ': ' + str(e) + '\n')
         sys.exit(1)

      # ====== Check whether information is complete ========================
      if not 'port_version_string' in packageInfo:
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + debianChangelogName + '!\n')
         sys.exit(1)

   return packageInfo


# ###### Read other packaging information ###################################
def readOtherPackagingInformation():

   # ====== Initialise ======================================================
   packageInfo = {}

   # ====== Obtain package configuration ====================================
   for otherFileName in [ 'version' ]:
      if os.path.isfile(otherFileName):
         break

   if os.path.isfile(otherFileName):
      packageInfo['other_file_name'] = otherFileName
      re_otherfile_version = re.compile(r'(\S+) (\d).(\d).(\d+)([~+][a-zA-Z0-9\.+]+|)')
      try:
         otherFile = open(otherFileName, 'r', encoding='utf-8')
         otherFileContents = otherFile.readlines()
         line = otherFileContents[0]
         match = re_otherfile_version.match(line)
         if match != None:
            packageInfo['other_package']       = match.group(1)
            packageInfo['other_version_major'] = int(match.group(2))
            packageInfo['other_version_minor'] = int(match.group(3))
            packageInfo['other_version_patch'] = int(match.group(4))
            packageInfo['other_version_extra'] = match.group(5)
            packageInfo['other_version_string'] = \
               str(packageInfo['other_version_major']) + '.' + \
               str(packageInfo['other_version_minor']) + '.' + \
               str(packageInfo['other_version_patch']) + packageInfo['other_version_extra']
         otherFile.close()

      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + otherFileName + ': ' + str(e) + '\n')
         sys.exit(1)

      # ====== Check whether information is complete ========================
      if not 'other_version_major' in packageInfo:
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + debianChangelogName + '!\n')
         sys.exit(1)

   return packageInfo


# ###### Read packaging information #########################################
def readPackagingInformation():

   # ====== Read information from different packaging system files ==========
   packageInfo = readPackagingConfiguration()

   cmakePackageInfo = readCMakePackagingInformation()
   if cmakePackageInfo != None:
      packageInfo.update(cmakePackageInfo)

   autoconfPackageInfo = readAutoConfPackagingInformation()
   if autoconfPackageInfo != None:
      packageInfo.update(autoconfPackageInfo)

   debianPackageInfo = readDebianPackagingInformation()
   if debianPackageInfo != None:
      packageInfo.update(debianPackageInfo)

   rpmPackageInfo = readRPMPackagingInformation()
   if rpmPackageInfo != None:
      packageInfo.update(rpmPackageInfo)

   freeBSDPackageInfo = readFreeBSDPackagingInformation()
   if freeBSDPackageInfo != None:
      packageInfo.update(freeBSDPackageInfo)

   otherPackageInfo = readOtherPackagingInformation()
   if otherPackageInfo != None:
      packageInfo.update(otherPackageInfo)


   # ====== Obtain master packaging information =============================
   for system in Systems:
      systemPrefix     = system[0]
      systemName       = system[1]
      systemConfigFile = system[2]
      if hasPackagingFor(packageInfo, systemPrefix):
         sys.stdout.write('Using master versioning from ' + systemName + '.\n')
         for entry in [ 'package', 'version_string',  'version_major',  'version_minor',  'version_patch',  'version_extra' ]:
            packageInfo['master_' + entry] = packageInfo[systemPrefix + '_' + entry]
         break
   if not hasPackagingFor(packageInfo, 'master'):
      sys.stderr.write('ERROR: Unable to obtain master packaging information!\n')
      sys.exit(1)


   # ====== Check master packaging information ==============================
   for system in Systems:
      systemPrefix     = system[0]
      systemName       = system[1]
      systemConfigFile = system[2]
      if hasPackagingFor(packageInfo, systemPrefix):
         sys.stdout.write(('Version from ' + systemName + ': ').ljust(32, ' ') + \
                          packageInfo[systemPrefix + '_version_string'] + \
                          ' (from ' + packageInfo[systemConfigFile] + ')\n')
         if packageInfo[systemPrefix + '_version_string'] != packageInfo['master_version_string']:
            sys.stderr.write('ERROR: ' + systemName + ' version ' + \
                             packageInfo[systemPrefix + '_version_string'] + ' does not match master version ' + \
                             packageInfo['master_version_string'] + '!\n')
            sys.exit(1)


   # ====== Look for source tarball =========================================
   sourcePackageInfo = findSourceTarball(packageInfo)
   if sourcePackageInfo != None:
      packageInfo.update(sourcePackageInfo)

   return packageInfo


# ###### Find source tarball ################################################
def findSourceTarball(packageInfo, quiet = False):

   # ====== Initialise ======================================================
   sourceInfo = {}

   # ====== Obtain package configuration ====================================
   tarballPattern = packageInfo['master_package'] + '-' + packageInfo['master_version_string'] + '.tar.*'
   if not quiet:
      sys.stdout.write('Looking for tarball ' + tarballPattern + ' ... ')
   tarballs = glob.glob(tarballPattern)   # NOTE: This will also find .tar.xz.asc, etc.!
   for tarball in tarballs:
      extension = os.path.splitext(tarball)[1][1:]
      if extension in TarballFormats:
         sourceInfo['source_tarball_name']      = tarball
         sourceInfo['source_tarball_format']    = extension

         # ====== Check for signature file ==================================
         signature = sourceInfo['source_tarball_name'] + '.asc'
         if os.path.isfile(signature):
            sourceInfo['source_tarball_signature'] = signature

         if not quiet:
            sys.stdout.write('Found ' + sourceInfo['source_tarball_name'] + \
                           ' (format is ' + sourceInfo['source_tarball_format'] + ', signature in ')
            if 'source_tarball_signature' in sourceInfo:
               sys.stdout.write(sourceInfo['source_tarball_signature'] + ').\n')
            else:
               sys.stdout.write('MISSING!).\n')

         return sourceInfo

   if not quiet:
      sys.stdout.write('not found!\n')
   return None


# ###### Check whether specific packaging information is available ##########
def hasPackagingFor(packageInfo, variant):
   if variant + '_version_string' in packageInfo:
      return True
   return False



# ###########################################################################
# #### Tools                                                             ####
# ###########################################################################


# ###### Show package information ###########################################
def showInformation(packageInfo):
   pprint.pprint(packageInfo, indent=1)


# ###### Make source tarball ################################################
def makeSourceTarball(packageInfo, skipPackageSigning):

   printSection('Creating source tarball')
   print(packageInfo['packaging_make_dist'])

   # ====== Make tarball ====================================================
   result = os.system(packageInfo['packaging_make_dist'])
   if result != 0:
      sys.stderr.write('ERROR: Unable to create source tarball!\n')
      return False
   sourcePackageInfo = findSourceTarball(packageInfo, quiet=(not skipPackageSigning))
   if sourcePackageInfo == None:
      sys.stderr.write('ERROR: Unable to find source tarball!\n')

   # ====== Sign tarball ====================================================
   # The source tarball is new, i.e. an existing signature is obsolete and
   # must be deleted.
   try:
      os.unlink(sourcePackageInfo['source_tarball_name'] + '.asc')
   except FileNotFoundError:
      pass
   if skipPackageSigning == False:
      result = os.system('gpg --sign --armor --detach-sign ' + \
                         sourcePackageInfo['source_tarball_name'])
      if result != 0:
         sys.stderr.write('ERROR: Unable to sign source tarball!\n')
         return False
      sourcePackageInfo = findSourceTarball(packageInfo)
      if ( (sourcePackageInfo == None) or
           (not 'source_tarball_name' in sourcePackageInfo) ):
         sys.stderr.write('ERROR: Unable to find signature of source tarball!\n')

   packageInfo.update(sourcePackageInfo)
   return True


# ###### Make Debian source package #########################################
def makeSourceDeb(packageInfo, skipPackageSigning):

   if not hasPackagingFor(packageInfo, 'debian'):
      sys.stderr.write('ERROR: Cannot find required Debian packaging information!\n')
      sys.exit(1)


# ###### Build Debian binary package ########################################
def buildDeb(packageInfo, skipPackageSigning):

   if not hasPackagingFor(packageInfo, 'debian'):
      sys.stderr.write('ERROR: Cannot find required Debian packaging information!\n')
      sys.exit(1)



# ###########################################################################
# #### Main Program                                                      ####
# ###########################################################################

# ====== Check arguments ====================================================
if len(sys.argv) < 2:
   sys.stderr.write('Usage: ' + sys.argv[0] + ' tool [options ...]\n')
   sys.stderr.write('* ' + sys.argv[0] + ' info\n')
   sys.stderr.write('* ' + sys.argv[0] + ' make-source-tarball [--skip-signing]\n')
   sys.stderr.write('* ' + sys.argv[0] + ' make-source-deb [--skip-signing]\n')
   # |make-source-tarball|make-source-deb|make-source-rpm|build-deb|build-rpm ...\n')
   sys.exit(1)


packageInfo = readPackagingInformation()

tool = sys.argv[1]

# ====== Print information ==================================================
if tool == 'info':
   showInformation(packageInfo)

# ====== Make source tarball ================================================
elif tool == 'make-source-tarball':
   skipPackageSigning = False
   for i in range(2, len(sys.argv)):
      if sys.argv[i] == '--skip-signing':
         skipPackageSigning = True
      else:
         sys.stderr.write('ERROR: Bad parameter ' + sys.argv[i] + '!\n')
         sys.exit(1)
   result = makeSourceTarball(packageInfo, skipPackageSigning)
   if result == False:
      sys.exit(1)

# ====== Make source deb file ===============================================
elif tool == 'make-source-deb':
   skipPackageSigning = False
   for i in range(2, len(sys.argv)):
      if sys.argv[i] == '--skip-signing':
         skipPackageSigning = True
      else:
         sys.stderr.write('ERROR: Bad parameter ' + sys.argv[i] + '!\n')
         sys.exit(1)
   makeSourceDeb(packageInfo, skipPackageSigning)

# ====== Build deb file =====================================================
elif tool == 'build-deb':
   True # buildDeb(packageInfo)

# ====== Invalid tool =======================================================
else:
   sys.stderr.write('ERROR: Invalid tool "' + tool + '"\n')
   sys.exit(1)
