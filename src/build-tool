#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Unified Build Tool
# Copyright (C) 2021-2022 by Thomas Dreibholz
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact: dreibh@iem.uni-due.de

import glob
import os
import pprint
import re
import shutil
import subprocess
import sys
import tempfile
import time
import urllib.error
import urllib.request


# ###########################################################################
# #### Constants                                                         ####
# ###########################################################################

TarballFormats = [ 'xz', 'bz2', 'gz' ]
TarOptions = {
   'xz':  'J',
   'bz2': 'j',
   'gz':  'z'
}

Systems = [
   # Prefix       System Name         Configuration File
   [ 'cmake',    'CMake',             'cmake_lists_name'      ],
   [ 'autoconf', 'AutoConf/AutoMake', 'autoconf_config_name'  ],
   [ 'other',    'Version File',      'other_file_name'       ],
   [ 'rpm',      'RPM Spec',          'rpm_spec_name'         ],
   [ 'debian',   'Debian Changelog',  'debian_changelog_name' ],
   [ 'port',     'Port Makefile',     'port_makefile_name'    ]
]

DebianCodenames = [
   'unstable', 'testing', 'stable', 'oldstable', 'sid',
   'bookworm', 'bullseye', 'buster', 'stretch', 'jessie', 'wheezy', 'squeeze',

   'bookworm-backports', 'bullseye-backports', 'buster-backports', 'stretch-backports',
   'jessie-backports', 'wheezy-backports', 'squeeze-backports',

   'bookworm-backports-sloppy', 'bullseye-backports-sloppy', 'buster-backports-sloppy',
   'stretch-backports-sloppy', 'jessie-backports-sloppy', 'wheezy-backports-sloppy',
   'squeeze-backports-sloppy',
]



# ###########################################################################
# #### Helper Functions                                                  ####
# ###########################################################################


# ###### Print section header ###############################################
def printSection(title):
   now = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime())
   sys.stdout.write('\n\x1b[34m' + (now + ' ====== ' + title + ' ').ljust(132, '=') + '\x1b[0m\n\n')


# ###### Print subsection header ############################################
def printSubsection(title):
   now = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime())
   sys.stdout.write('\n\x1b[34m' + (now + ' ------ ' + title + ' ').ljust(132, '-') + '\x1b[0m\n')



# ###########################################################################
# #### Packaging                                                         ####
# ###########################################################################


# ###### Read packaging configuration from packaging.conf ###################
def readPackagingConfiguration():

   # ====== Initialise ======================================================
   packageInfo = {}
   packageInfo['packaging_maintainer']      = None
   packageInfo['packaging_maintainer_key']  = None
   packageInfo['packaging_make_dist']       = None
   packageInfo['packaging_config_name']     = 'packaging.conf'

   # ====== Obtain package configuration ====================================
   re_package_maintainer     = re.compile(r'^(MAINTAINER=\")(.*)(\".*$)')
   re_package_maintainer_key = re.compile(r'^(MAINTAINER_KEY=\")(.*)(\".*$)')
   re_package_makedist       = re.compile(r'^(MAKE_DIST=\")(.*)(\".*$)')
   try:
      packagingConfFile = open(packageInfo['packaging_config_name'], 'r', encoding='utf-8')
      packagingConfFileContents = packagingConfFile.readlines()
      for line in packagingConfFileContents:
         match = re_package_maintainer.match(line)
         if match != None:
            packageInfo['packaging_maintainer'] = match.group(2)
         else:
            match = re_package_maintainer_key.match(line)
            if match != None:
               packageInfo['packaging_maintainer_key'] = match.group(2)
            else:
               match = re_package_makedist.match(line)
               if match != None:
                  packageInfo['packaging_make_dist'] = match.group(2)
      packagingConfFile.close()
   except Exception as e:
      sys.stderr.write('ERROR: Unable to read ' + packageInfo['packaging_config_name'] + ': ' + str(e) + '\n')
      sys.exit(1)

   if packageInfo['packaging_maintainer'] == None:
      sys.stderr.write('ERROR: Unable to find MAINTAINER in ' + packageInfo['packaging_config_name'] + '!\n')
      sys.exit(1)
   elif packageInfo['packaging_make_dist'] == None:
      sys.stderr.write('ERROR: Unable to find MAKE_DIST in ' + packageInfo['packaging_config_name'] + '!\n')
      sys.exit(1)

   return packageInfo


# ###### Read CMake packaging information ###################################
def readCMakePackagingInformation():

   # ====== Initialise ======================================================
   packageInfo = {}

   # ====== Obtain package configuration ====================================
   cmakeListsFile = 'CMakeLists.txt'
   if os.path.isfile(cmakeListsFile):
      re_cmake_project   = re.compile(r'[ \t]*PROJECT[ \t]*\(([a-zA-Z0-9-+]+)')
      re_cmakefile_major = re.compile(r'^[Ss][Ee][Tt]\(BUILD_MAJOR[ \t]*"(\d+)"[ \t]*\)')
      re_cmakefile_minor = re.compile(r'^[Ss][Ee][Tt]\(BUILD_MINOR[ \t]*"(\d+)"[ \t]*\)')
      re_cmakefile_patch = re.compile(r'^[Ss][Ee][Tt]\(BUILD_PATCH[ \t]*"(\d+)(~[a-zA-Z0-9\.+]+|)"[ \t]*\)')

      packageInfo['cmake_lists_name'] = cmakeListsFile
      try:
         cmakeFile = open(packageInfo['cmake_lists_name'], 'r', encoding='utf-8')
         cmakeFileContents = cmakeFile.readlines()
         for line in cmakeFileContents:
            match = re_cmakefile_major.match(line)
            if match != None:
               packageInfo['cmake_version_major'] = int(match.group(1))
            else:
               match = re_cmakefile_minor.match(line)
               if match != None:
                  packageInfo['cmake_version_minor'] = int(match.group(1))
               else:
                  match = re_cmakefile_patch.match(line)
                  if match != None:
                     packageInfo['cmake_version_patch'] = int(match.group(1))
                     packageInfo['cmake_version_extra'] = match.group(2)
                  else:
                     match = re_cmake_project.match(line)
                     if match != None:
                        packageInfo['cmake_package'] = match.group(1)
         cmakeFile.close()

         if (packageInfo['cmake_version_major'] != None) and \
            (packageInfo['cmake_version_minor'] != None) and \
            (packageInfo['cmake_version_patch'] != None) and \
            (packageInfo['cmake_version_extra'] != None):
            packageInfo['cmake_version_string'] = str(packageInfo['cmake_version_major']) + '.' + \
                                 str(packageInfo['cmake_version_minor']) + '.' + \
                                 str(packageInfo['cmake_version_patch']) + packageInfo['cmake_version_extra']

      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + packageInfo['cmake_lists_name'] + ': ' + str(e) + '\n')
         sys.exit(1)

      # ====== Check whether information is complete ========================
      if ( ( not 'cmake_package' in packageInfo) or
           ( not 'cmake_version_string' in packageInfo ) ):
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + packageInfo['cmake_lists_name'] + '!\n')
         sys.exit(1)

   return packageInfo


# ###### Read AutoConf packaging information ################################
def readAutoConfPackagingInformation():

   # ====== Initialise ======================================================
   packageInfo = {}

   # ====== Obtain package configuration ====================================
   for autoconfConfigName in [ 'configure.ac', 'configure.in' ]:
      if os.path.isfile(autoconfConfigName):
         break
   if os.path.isfile(autoconfConfigName):
      re_autoconffile_version = re.compile(r'^AC_INIT\([ \t]*\[(.*)\][ \t]*,[ \t]*\[(\d).(\d).(\d+)([~+][a-zA-Z0-9\.+]+|)\][ \t]*,[ \t]*\[(.*)\][ \t]*\)')

      packageInfo['autoconf_config_name'] = autoconfConfigName
      try:
         autoconfFile = open(packageInfo['autoconf_config_name'], 'r', encoding='utf-8')
         autoconfFileContents = autoconfFile.readlines()
         for line in autoconfFileContents:
            match = re_autoconffile_version.match(line)
            if match != None:
               packageInfo['autoconf_package']       = match.group(1)
               packageInfo['autoconf_version_major'] = int(match.group(2))
               packageInfo['autoconf_version_minor'] = int(match.group(3))
               packageInfo['autoconf_version_patch'] = int(match.group(4))
               packageInfo['autoconf_version_extra'] = match.group(5)
               packageInfo['autoconf_version_string'] = \
                  str(packageInfo['autoconf_version_major']) + '.' + \
                  str(packageInfo['autoconf_version_minor']) + '.' + \
                  str(packageInfo['autoconf_version_patch']) + packageInfo['autoconf_version_extra']
               break
         autoconfFile.close()

      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + packageInfo['autoconf_config_name'] + ': ' + str(e) + '\n')
         sys.exit(1)

      # ====== Check whether information is complete ========================
      if ( ( not 'autoconf_package' in packageInfo) or
           ( not 'autoconf_version_string' in packageInfo ) ):
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + packageInfo['autoconf_config_name'] + '!\n')
         sys.exit(1)

   return packageInfo


# ###### Read Debian packaging information ##################################
def readDebianPackagingInformation():

   # ====== Initialise ======================================================
   packageInfo = {}

   # ====== Process changelog file ==========================================
   debianChangelogName = 'debian/changelog'
   debianControlName   = 'debian/control'
   if os.path.isfile(debianChangelogName):
      re_debian_version = re.compile(r'^([a-zA-Z0-9-+]+)[ \t]*\((\d+:|)(\d+)\.(\d+)\.(\d+)(.*|)-(\d|\d[a-zA-Z-+~]+\d|)\)[ \t]*([a-zA-Z-+]+)[ \t]*;')
      re_debian_itp1    = re.compile(r'^ * .*ITP.*Closes: #([0-9]+).*$')
      re_debian_itp2    = re.compile(r'^ * .*Closes: #([0-9]+).*ITP.*$')

      packageInfo['debian_changelog_name']    = debianChangelogName
      packageInfo['debian_control_name']      = debianControlName
      packageInfo['debian_package_name']      = None
      packageInfo['debian_version_string']    = None
      packageInfo['debian_standards_version'] = None
      packageInfo['debian_codename']          = None
      packageInfo['debian_itp']               = None
      packageInfo['debian_status']            = None

      try:
         debianChangeLogFile = open(debianChangelogName, 'r', encoding='utf-8')
         debianChangeLogFileContents = debianChangeLogFile.readlines()
         n = 0
         for line in debianChangeLogFileContents:
            n = n + 1
            if n == 1:
               match = re_debian_version.match(line)
               if match != None:
                  packageInfo['debian_package_name']      = match.group(1)
                  packageInfo['debian_version_prefix']    = match.group(2)
                  packageInfo['debian_version_major']     = int(match.group(3))
                  packageInfo['debian_version_minor']     = int(match.group(4))
                  packageInfo['debian_version_patch']     = int(match.group(5))
                  packageInfo['debian_version_extra']     = match.group(6)
                  packageInfo['debian_version_packaging'] = match.group(7)
                  packageInfo['debian_codename']          = match.group(8)
                  packageInfo['debian_version_string']    = \
                     str(packageInfo['debian_version_major']) + '.' + \
                     str(packageInfo['debian_version_minor']) + '.' + \
                     str(packageInfo['debian_version_patch']) + packageInfo['debian_version_extra']
            elif n > 1:
               match = re_debian_itp1.match(line)
               if match == None:
                  match = re_debian_itp2.match(line)
               if match != None:
                  # print('ITP: ' + line)
                  packageInfo['debian_itp'] = int(match.group(1))
                  break
         debianChangeLogFile.close()

      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + debianChangelogName + ': ' + str(e) + '\n')
         sys.exit(1)

      if packageInfo['debian_package_name'] == None:
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + debianChangelogName + '!\n')
         sys.exit(1)

      # ====== Check whether information is complete ========================
      if not 'debian_package_name' in packageInfo:
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + debianChangelogName + '!\n')
         sys.exit(1)

      # ====== Process control file =========================================
      re_debian_standards_version = re.compile(r'^Standards-Version:[ \t]*([0-9\.]*)[ \t]*$')
      try:
         debianControlFile = open(debianControlName, 'r', encoding='utf-8')
         debianControlFileContents = debianControlFile.readlines()
         for line in debianControlFileContents:
            match = re_debian_standards_version.match(line)
            if match != None:
               packageInfo['debian_standards_version'] = match.group(1)
         debianControlFile.close()
      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + debianControlName + ': ' + str(e) + '\n')
         sys.exit(1)

   return packageInfo


# ###### Read RPM packaging information #####################################
def readRPMPackagingInformation():

   # ====== Initialise ======================================================
   packageInfo = {}

   # ====== Obtain package configuration ====================================
   rpm_spec_names = glob.glob('rpm/*.spec')
   if len(rpm_spec_names) > 0:
      packageInfo['rpm_spec_name'] = rpm_spec_names[0]

      re_rpm_name    = re.compile(r'^(Name:[ \t]*)(\S+)')
      re_rpm_version = re.compile(r'^(Version:[ \t]*)(\d+)\.(\d+)\.(\d+)(.*|)')
      re_rpm_release = re.compile(r'^(Release:[ \t]*)(\d+)')
      try:
         rpmSpecFile = open(packageInfo['rpm_spec_name'], 'r', encoding='utf-8')
         rpmSpecFileContents = rpmSpecFile.readlines()
         packageInfo['rpm_version_packaging'] = None
         for line in rpmSpecFileContents:
            match = re_rpm_version.match(line)
            if match != None:
               packageInfo['rpm_version_major']  = int(match.group(2))
               packageInfo['rpm_version_minor']  = int(match.group(3))
               packageInfo['rpm_version_patch']  = int(match.group(4))
               packageInfo['rpm_version_extra']  = match.group(5)
               packageInfo['rpm_version_string'] = \
                  str(packageInfo['rpm_version_major']) + '.' + \
                  str(packageInfo['rpm_version_minor']) + '.' + \
                  str(packageInfo['rpm_version_patch']) + packageInfo['rpm_version_extra']
            else:
               match = re_rpm_release.match(line)
               if match != None:
                  packageInfo['rpm_version_packaging'] = int(match.group(2))
               else:
                  match = re_rpm_name.match(line)
                  if match != None:
                     packageInfo['rpm_package_name'] = match.group(2)
         rpmSpecFile.close()

      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + packageInfo['rpm_spec_name'] + ': ' + str(e) + '\n')
         sys.exit(1)

      # ====== Check whether information is complete ========================
      if ( (not 'rpm_package_name' in packageInfo) or
           (not 'rpm_version_packaging' in packageInfo) ):
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + packageInfo['rpm_spec_name'] + '!\n')
         sys.exit(1)

   return packageInfo


# ###### Read FreeBSD ports packaging information ###########################
def readFreeBSDPackagingInformation():

   # ====== Initialise ======================================================
   packageInfo = {}
   port_makefile_names = glob.glob('freebsd/*/Makefile')

   # ====== Obtain package configuration ====================================
   if len(port_makefile_names) > 0:
      packageInfo['port_makefile_name'] = port_makefile_names[0]
      re_freebsd_version = re.compile(r'^(PORTVERSION=[ \t]*)(\d+)\.(\d+)\.(\d+)(.*|)')
      try:
         freeBSDMakefileFile = open(packageInfo['port_makefile_name'], 'r', encoding='utf-8')
         freeBSDMakefileFileContents = freeBSDMakefileFile.readlines()
         for line in freeBSDMakefileFileContents:
            match = re_freebsd_version.match(line)
            if match != None:
               packageInfo['port_version_major']  = int(match.group(2))
               packageInfo['port_version_minor']  = int(match.group(3))
               packageInfo['port_version_patch']  = int(match.group(4))
               packageInfo['port_version_extra']  = match.group(5)
               packageInfo['port_version_string'] = \
                  str(packageInfo['port_version_major']) + '.' + \
                  str(packageInfo['port_version_minor']) + '.' + \
                  str(packageInfo['port_version_patch']) + packageInfo['port_version_extra']
         freeBSDMakefileFile.close()

      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + packageInfo['port_makefile_name'] + ': ' + str(e) + '\n')
         sys.exit(1)

      # ====== Check whether information is complete ========================
      if not 'port_version_string' in packageInfo:
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + debianChangelogName + '!\n')
         sys.exit(1)

   return packageInfo


# ###### Read other packaging information ###################################
def readOtherPackagingInformation():

   # ====== Initialise ======================================================
   packageInfo = {}

   # ====== Obtain package configuration ====================================
   for otherFileName in [ 'version' ]:
      if os.path.isfile(otherFileName):
         break

   if os.path.isfile(otherFileName):
      packageInfo['other_file_name'] = otherFileName
      re_otherfile_version = re.compile(r'(\S+) (\d).(\d).(\d+)([~+][a-zA-Z0-9\.+]+|)')
      try:
         otherFile = open(otherFileName, 'r', encoding='utf-8')
         otherFileContents = otherFile.readlines()
         line = otherFileContents[0]
         match = re_otherfile_version.match(line)
         if match != None:
            packageInfo['other_package']       = match.group(1)
            packageInfo['other_version_major'] = int(match.group(2))
            packageInfo['other_version_minor'] = int(match.group(3))
            packageInfo['other_version_patch'] = int(match.group(4))
            packageInfo['other_version_extra'] = match.group(5)
            packageInfo['other_version_string'] = \
               str(packageInfo['other_version_major']) + '.' + \
               str(packageInfo['other_version_minor']) + '.' + \
               str(packageInfo['other_version_patch']) + packageInfo['other_version_extra']
         otherFile.close()

      except Exception as e:
         sys.stderr.write('ERROR: Unable to read ' + otherFileName + ': ' + str(e) + '\n')
         sys.exit(1)

      # ====== Check whether information is complete ========================
      if not 'other_version_major' in packageInfo:
         sys.stderr.write('ERROR: Cannot find required package versioning details in ' + debianChangelogName + '!\n')
         sys.exit(1)

   return packageInfo


# ###### Read packaging information #########################################
def readPackagingInformation():

   # ====== Read information from different packaging system files ==========
   packageInfo = readPackagingConfiguration()

   cmakePackageInfo = readCMakePackagingInformation()
   if cmakePackageInfo != None:
      packageInfo.update(cmakePackageInfo)

   autoconfPackageInfo = readAutoConfPackagingInformation()
   if autoconfPackageInfo != None:
      packageInfo.update(autoconfPackageInfo)

   debianPackageInfo = readDebianPackagingInformation()
   if debianPackageInfo != None:
      packageInfo.update(debianPackageInfo)

   rpmPackageInfo = readRPMPackagingInformation()
   if rpmPackageInfo != None:
      packageInfo.update(rpmPackageInfo)

   freeBSDPackageInfo = readFreeBSDPackagingInformation()
   if freeBSDPackageInfo != None:
      packageInfo.update(freeBSDPackageInfo)

   otherPackageInfo = readOtherPackagingInformation()
   if otherPackageInfo != None:
      packageInfo.update(otherPackageInfo)


   # ====== Obtain master packaging information =============================
   for system in Systems:
      systemPrefix     = system[0]
      systemName       = system[1]
      systemConfigFile = system[2]
      if hasPackagingFor(packageInfo, systemPrefix):
         sys.stdout.write('Using master versioning from ' + systemName + '.\n')
         for entry in [ 'package', 'version_string',  'version_major',  'version_minor',  'version_patch',  'version_extra' ]:
            packageInfo['master_' + entry] = packageInfo[systemPrefix + '_' + entry]
         break
   if not hasPackagingFor(packageInfo, 'master'):
      sys.stderr.write('ERROR: Unable to obtain master packaging information!\n')
      sys.exit(1)


   # ====== Check master packaging information ==============================
   for system in Systems:
      systemPrefix     = system[0]
      systemName       = system[1]
      systemConfigFile = system[2]
      if hasPackagingFor(packageInfo, systemPrefix):
         sys.stdout.write(('Version from ' + systemName + ': ').ljust(32, ' ') + \
                          packageInfo[systemPrefix + '_version_string'] + \
                          ' (from ' + packageInfo[systemConfigFile] + ')\n')
         if packageInfo[systemPrefix + '_version_string'] != packageInfo['master_version_string']:
            sys.stderr.write('ERROR: ' + systemName + ' version ' + \
                             packageInfo[systemPrefix + '_version_string'] + ' does not match master version ' + \
                             packageInfo['master_version_string'] + '!\n')
            sys.exit(1)


   # ====== Look for source tarball =========================================
   sourcePackageInfo = findSourceTarball(packageInfo)
   if sourcePackageInfo != None:
      packageInfo.update(sourcePackageInfo)

   return packageInfo


# ###### Find source tarball ################################################
def findSourceTarball(packageInfo, quiet = False):

   # ====== Initialise ======================================================
   sourceInfo = {}

   # ====== Obtain package configuration ====================================
   tarballPattern = packageInfo['master_package'] + '-' + packageInfo['master_version_string'] + '.tar.*'
   if not quiet:
      sys.stdout.write('Looking for tarball ' + tarballPattern + ' ... ')
   tarballs = glob.glob(tarballPattern)   # NOTE: This will also find .tar.xz.asc, etc.!
   for tarball in tarballs:
      extension = os.path.splitext(tarball)[1][1:]
      if extension in TarballFormats:
         sourceInfo['source_tarball_name']      = tarball
         sourceInfo['source_tarball_format']    = extension

         # ====== Check for signature file ==================================
         signature = sourceInfo['source_tarball_name'] + '.asc'
         if os.path.isfile(signature):
            sourceInfo['source_tarball_signature'] = signature

         if not quiet:
            sys.stdout.write('Found ' + sourceInfo['source_tarball_name'] + \
                           ' (format is ' + sourceInfo['source_tarball_format'] + ', signature in ')
            if 'source_tarball_signature' in sourceInfo:
               sys.stdout.write(sourceInfo['source_tarball_signature'] + ').\n')
            else:
               sys.stdout.write('MISSING!).\n')

         return sourceInfo

   if not quiet:
      sys.stdout.write('not found!\n')
   return None


# ###### Check whether specific packaging information is available ##########
def hasPackagingFor(packageInfo, variant):
   if variant + '_version_string' in packageInfo:
      return True
   return False



# ###########################################################################
# #### Tools                                                             ####
# ###########################################################################


# ###### Show package information ###########################################
def showInformation(packageInfo):
   pprint.pprint(packageInfo, indent=1)


# ###### Make source tarball ################################################
def makeSourceTarball(packageInfo, skipPackageSigning):

   printSection('Creating source tarball')

   # ====== Make source tarball =============================================
   if 'source_tarball_name' in packageInfo:
      sourcePackageInfo = findSourceTarball(packageInfo, quiet=True)
      sys.stdout.write('Tarball is already there: ' + packageInfo['source_tarball_name'] + \
                       ' (format is ' + packageInfo['source_tarball_format'] + ')\n')
   else:
      print(packageInfo['packaging_make_dist'])
      result = os.system(packageInfo['packaging_make_dist'])
      if result != 0:
         sys.stderr.write('ERROR: Unable to create source tarball!\n')
         return False
      sourcePackageInfo = findSourceTarball(packageInfo, quiet=(not skipPackageSigning))
      if sourcePackageInfo == None:
         sys.stderr.write('ERROR: Unable to find source tarball!\n')
         return False
      # The source tarball is new, i.e. an existing signature is obsolete and
      # must be deleted.
      try:
         os.unlink(sourcePackageInfo['source_tarball_name'] + '.asc')
      except FileNotFoundError:
         pass

   # ====== Sign tarball ====================================================
   if skipPackageSigning == False:
      if 'source_tarball_signature' in sourcePackageInfo:
         sys.stdout.write('Signature is already there: ' + sourcePackageInfo['source_tarball_signature'] + '\n')

      else:
         result = os.system('gpg --sign --armor --detach-sign ' + \
                           sourcePackageInfo['source_tarball_name'])
         if result != 0:
            sys.stderr.write('ERROR: Unable to sign source tarball!\n')
            return False
         sourcePackageInfo = findSourceTarball(packageInfo)
         if ( (sourcePackageInfo == None) or
            (not 'source_tarball_name' in sourcePackageInfo) ):
            sys.stderr.write('ERROR: Unable to find signature of source tarball!\n')

      result = os.system('gpg --verify ' + \
                           sourcePackageInfo['source_tarball_signature'] + ' ' + \
                           sourcePackageInfo['source_tarball_name'])
      if result == 0:
         sys.stderr.write('Signature verified.\n')
      else:
         sys.stderr.write('ERROR: Bad signature! Something is wrong!\n')
         return False

   packageInfo.update(sourcePackageInfo)
   return True


# ###### Make Debian source package #########################################
def makeSourceDeb(packageInfo, codenames, skipPackageSigning):

   # ====== Make sure that the source tarball is available ==================
   if makeSourceTarball(packageInfo, skipPackageSigning) == False:
      return False
   if len(codenames) == 0:
      codenames = [ packageInfo['debian_codename'] ]


   # ====== Build for each distribution codename ============================
   printSection('Creating source Debian packages')

   # Make sure to have the original packages with their Debian names:
   originalTarball = packageInfo['debian_package_name'] + '_' + \
                        packageInfo['debian_version_string'] + '.orig.tar.' + \
                        packageInfo['source_tarball_format']
   originalSignature = originalTarball + '.asc'
   try:
      os.link(packageInfo['source_tarball_name'], originalTarball)
   except FileExistsError:
      pass
   if skipPackageSigning == False:
      try:
         os.link(packageInfo['source_tarball_signature'], originalSignature)
      except FileExistsError:
         pass

   for codename in codenames:
      printSubsection('Creating source Debian package for ' + codename)

      # ====== Prepare work directory =======================================
      workdir = '/tmp/packaging-' + \
         codename + '-' + \
         packageInfo['debian_package_name'] + '-' + \
         packageInfo['debian_version_string'] + '-' + \
         packageInfo['debian_version_packaging']
      sys.stdout.write('Preparing work directory ' + workdir + ' ...\n')

      shutil.rmtree(workdir, ignore_errors = True)
      os.makedirs(workdir, exist_ok = True)

      # !!! Using *symlink* below! !!!
      # shutil.copyfile(originalTarball, workdir + '/' + originalTarball)
      # if skipPackageSigning == False:
          #shutil.copyfile(originalSignature, workdir + '/' + originalSignature)
      os.symlink(os.path.abspath(packageInfo['source_tarball_name']), workdir + '/' + originalTarball)
      if skipPackageSigning == False:
         os.symlink(os.path.abspath(packageInfo['source_tarball_signature']), workdir + '/' + originalSignature)


      # ====== Unpack the sources ===========================================
      compressionOption = TarOptions[packageInfo['source_tarball_format']]
      try:
         subprocess.run([ 'tar', 'x' + compressionOption + 'f', originalTarball ], cwd = workdir)
      except Exception as e:
         sys.stderr.write('ERROR: Unable to uncompress upstream source tarball ' + originalTarball + ': ' + str(e) + '\n')
         sys.exit(1)

      upstreamSourceDir = workdir + '/' + packageInfo['debian_package_name'] + '-' + packageInfo['debian_version_string']
      if not os.path.isdir(upstreamSourceDir):
         sys.stderr.write('ERROR: Sources are not in the expected directory ' + upstreamSourceDir + '!\n')
         sys.exit(1)


      # ====== Adapt packaging ==============================================

      # ------- Debian ------------------------------------------------------
      if codename in DebianCodenames:

         changeLogContents = readDebianChangelog(packageInfo)

         # ------ Update changelog ------------------------------------------
         # Update codename:
         changeLogContents[0] = re.sub(' ' + packageInfo['debian_codename'] + ';',
                                       ' ' + codename + ';',
                                       changeLogContents[0])
         # Drop Ubuntu packaging version:
         changeLogContents[0] = re.sub('(ubuntu|ppa)[0-9]', '',
                                       changeLogContents[0])
         # Remove Launchpad entries:
         re_launchpad = re.compile(r'^.*\(LP: #[0-9]+')
         changeLogContents = [ line for line in changeLogContents if not re_launchpad.match(line) ]

         # ------ Fetch distributor's latest changelog ----------------------
         uploadedChangelogContents = fetchDebianChangelog(packageInfo, codename)
         if uploadedChangelogContents != None:

            ## Fetch debian/changelog from Debian, if available.
            ## If there is a Debian changelog, merge new entries.
            #if ../fetch-debian-changelog ${PACKAGE} ${DISTRIBUTION} >debian/changelog.dist ; then
               #../merge-debian-changelogs debian/changelog debian/changelog.dist >debian/changelog.merged && \
                  #mv debian/changelog.merged debian/changelog
            #fi
            changeLogContents = mergeDebianChangelogs(originalChangeLogContents, uploadedChangelogContents)
            # FIXME! APPLY
            True

         filterDebianChangelog(changeLogContents, upstreamSourceDir + '/debian/changelog')


      # ------- Ubuntu ------------------------------------------------------
      else:
         print(packageInfo['debian_codename'])
         #sed -e "s/${PACKAGE_DISTRIBUTION};/${DISTRIBUTION};/1" \
             #-e "s/${PACKAGE_VERSION}/${OUTPUT_VERSION}~${DISTRIBUTION}1/1" \
             #-e "/(Closes: #/D" \
             #<debian/changelog | ../filter-debian-changelog "${UBUNTU_LAST_ENTRY}" >debian/changelog.new
         True


      # ====== Build source Debian package ==================================
      if skipPackageSigning == False:
         # Build source package including signature:
         if packageInfo['packaging_maintainer_key'] == None:
            sys.stderr.write('ERROR: No MAINTAINER_KEY in ' + packageInfo['packaging_config_name'] + '\n')
            sys.exit(1)
         subprocess.run([ 'debuild', '--no-check-builddeps', '-sa', '-S', '-k' + packageInfo['packaging_maintainer_key'], '-i' ],
                        cwd = upstreamSourceDir)
      else:
         # Build source package without signature:
         subprocess.run([ 'debuild', '--no-check-builddeps', '-us', '-uc', '-S', '-i' ], cwd = upstreamSourceDir)


      # ====== Check description file =======================================
      dscFile = packageInfo['debian_package_name'] + '_' + \
                   packageInfo['debian_version_string'] + '-' + \
                   packageInfo['debian_version_packaging'] + '.dsc'
      if not os.path.isfile(workdir + '/' + dscFile):
         sys.stderr.write('ERROR: DSC file not found at expected location ' + workdir + '/' + dscFile + '!\n')
         sys.exit(1)
      else:
         sys.stdout.write('DSC file is ' + workdir + '/' + dscFile + '.\n')

   return True


# ###### Build Debian binary package ########################################
def buildDeb(packageInfo, skipPackageSigning):

   if not hasPackagingFor(packageInfo, 'debian'):
      sys.stderr.write('ERROR: Cannot find required Debian packaging information!\n')
      sys.exit(1)


# ###### Read Debian changelog file #########################################
def readDebianChangelog(packageInfo):
   if not hasPackagingFor(packageInfo, 'debian'):
      sys.stderr.write('ERROR: Cannot find required Debian packaging information!\n')
      sys.exit(1)

   changelogFile = open(packageInfo['debian_changelog_name'], 'r', encoding='utf-8')
   changelogContents = changelogFile.readlines()
   changelogFile.close()

   return changelogContents


# ###### Fetch Debian changelog file ########################################
def fetchDebianChangelog(packageInfo, codename = 'unstable'):
   if not hasPackagingFor(packageInfo, 'debian'):
      sys.stderr.write('ERROR: Cannot find required Debian packaging information!\n')
      sys.exit(1)

   if codename in DebianCodenames:
      # Debian
      statusPageURL = 'https://packages.debian.org/source/' + codename + '/' + packageInfo['debian_package_name']
   else:
      # Ubuntu
      statusPageURL = 'https://packages.ubuntu.com/source/' + codename + '/' + packageInfo['debian_package_name']

   debianVersion       = None
   debianLocation      = None
   debianArchive       = None
   debianArchiveFormat = None

   # ====== Get package status =================================================
   statusPageContents = None
   sys.stderr.write('Looking for package status on ' + statusPageURL + ' ... ')
   sys.stderr.flush()
   try:
      statusPage = urllib.request.urlopen(statusPageURL)
      statusPageContents = statusPage.readlines()
      statusPage.close()

      re_debian_package = re.compile(r'.*Source Package: ' + packageInfo['debian_package_name'] + ' \(([0-9-+~\.a-z]+)\)')
      re_debian_archive = re.compile(r'.*href="((http|https)://[a-zA-Z0-9\./+-]+/' + \
                                       packageInfo['debian_package_name'][0:1] + '/' + \
                                       packageInfo['debian_package_name'] + '/' + \
                                       r')(' + packageInfo['debian_package_name'] + r'_[0-9-+~\.a-z]+\.debian\.tar\.[a-zA-Z]+)"')
      for line in statusPageContents:
         line = line.decode('utf-8')
         match = re_debian_package.match(line)
         if match != None:
            debianVersion = match.group(1)
         else:
            match = re_debian_archive.match(line)
            if match != None:
               debianLocation = match.group(1)
               debianArchive  = match.group(3)

   except urllib.error.HTTPError as e:
      sys.stderr.write('not found (HTTP ' + str(e.code) + ')!\n')
      sys.exit(1)

   if (debianVersion == None) or (debianArchive == None):
      sys.stderr.write('not found!\n')
      return None

   sys.stderr.write('Version in ' + codename + ' is ' + debianVersion + '\n')


   # ====== Determine necessary compression option =============================
   debianArchiveFormat  = debianArchive[len(debianArchive) - 2 : len(debianArchive)]
   tarCompressionOption = TarOptions[debianArchiveFormat]


   # ====== Fetch debian archive ===============================================
   archiveFileURL =  debianLocation + debianArchive
   sys.stderr.write('Looking for \"debian\" archive at ' + archiveFileURL + ' ... ')
   sys.stderr.flush()
   result = None
   try:
      archiveFile = urllib.request.urlopen(archiveFileURL)
      debianArchiveFile = tempfile.NamedTemporaryFile(delete=False)
      shutil.copyfileobj(archiveFile, debianArchiveFile)
      debianArchiveFile.close()
      archiveFile.close()
      sys.stderr.write('found!\n')

      try:

         process = subprocess.Popen([ 'tar', 'x' + tarCompressionOption + 'fO', debianArchiveFile.name, 'debian/changelog'],
                                    stdout=subprocess.PIPE, universal_newlines=True)
         result = process.stdout.readlines()
         os.unlink(debianArchiveFile.name)

      except Exception as e:
         sys.stderr.write('ERROR: Failed to extract debian/changelog from ' + debianArchiveFile.name + ': ' + str(e) + '\n')
         sys.exit(1)

   except urllib.error.HTTPError as e:
      sys.stderr.write('not found (HTTP ' + str(e.code) + ')!\n')
      return None

   return result



# ###########################################################################
# #### Main Program                                                      ####
# ###########################################################################

# ====== Check arguments ====================================================
if len(sys.argv) < 2:
   sys.stderr.write('Usage: ' + sys.argv[0] + ' tool [options ...]\n')
   sys.stderr.write('* ' + sys.argv[0] + ' info\n')
   sys.stderr.write('* ' + sys.argv[0] + ' make-source-tarball [--skip-signing]\n')
   sys.stderr.write('* ' + sys.argv[0] + ' make-source-deb  [codename ...] [--skip-signing]\n')
   sys.stderr.write('* ' + sys.argv[0] + ' fetch-debian-changelog [codename]\n')
   # |make-source-tarball|make-source-deb|make-source-rpm|build-deb|build-rpm ...\n')
   sys.exit(1)


packageInfo = readPackagingInformation()

tool = sys.argv[1]

# ====== Print information ==================================================
if tool == 'info':
   showInformation(packageInfo)

# ====== Make source tarball ================================================
elif tool == 'make-source-tarball':
   skipPackageSigning = False
   for i in range(2, len(sys.argv)):
      if sys.argv[i] == '--skip-signing':
         skipPackageSigning = True
      else:
         sys.stderr.write('ERROR: Bad parameter ' + sys.argv[i] + '!\n')
         sys.exit(1)
   result = makeSourceTarball(packageInfo, skipPackageSigning)
   if result == False:
      sys.exit(1)

# ====== Make source deb file ===============================================
elif tool == 'make-source-deb':
   skipPackageSigning = False
   codenames          = []
   for i in range(2, len(sys.argv)):
      if sys.argv[i][0] != '-':
         codenames.append(sys.argv[i])
      elif sys.argv[i] == '--skip-signing':
         skipPackageSigning = True
      else:
         sys.stderr.write('ERROR: Bad parameter ' + sys.argv[i] + '!\n')
         sys.exit(1)
   makeSourceDeb(packageInfo, codenames, skipPackageSigning)

# ====== Build deb file =====================================================
elif tool == 'build-deb':
   True # buildDeb(packageInfo)

# ====== Fetch Debian changelog file ========================================
elif tool == 'fetch-debian-changelog':
   skipPackageSigning = False
   codename           = 'unstable'
   if len(sys.argv) >= 3:
      codename = sys.argv[2]
   result = fetchDebianChangelog(packageInfo, codename)
   sys.stdout.write('\n')
   for line in result:
      sys.stdout.write(line)

# ====== Show Debian changelog file ========================================0
elif tool == 'show-debian-changelog':
   result = readDebianChangelog(packageInfo)
   sys.stdout.write('\n')
   for line in result:
      sys.stdout.write(line)


# ====== Invalid tool =======================================================
else:
   sys.stderr.write('ERROR: Invalid tool "' + tool + '"\n')
   sys.exit(1)
